- 폭포수 모델의 장점
    - 산출물을 통해 프로젝트의 진척사항을 관리하기 용이
    - 순차적인 선형 모델이므로 단순하고 이해하기 쉬움
    - 각 단계가 분리되어 있어 단계별로 정형화된 접근 방법과 체계적인 문서화 작업 간으
    - 각 단계별로 산출물을 체크함으로써 프로젝트 진행 상황을 명확하게 알 수 있음
- 애자일 방법론
    - 스크럼(Scrum)
      - 반복적/점증적 개발 과정을 어떻게 관리할 것인가에 초점
      - 스크럼 가이드에는 애자일 방법을 적용할 때 필요한 '프로세스 프레임워크'로 설명함
      - 애자일 원칙과 실천 지침을 반영한 '프로젝트 관리 프레임워크'로 보는 견해도 있음
    - 짝 프로그래밍
    - 익스트림 프로그래밍(XP)
        - 작고 빈번한 릴리스, 빠른 피드백과 지속적 개선
        - 고객도 개발 팀의 일원이 됨
        - 프로세스 중심이 아닌 사람 중심의 방법
        - 단순한 설계와 테스트 선행 개발
        - 코드의 품질 개선을 위해 리펙토링 제안
    - 테스트 선행 개발
    - 스프린트
        - 스린트는 1개월 이하의 작은 프로젝트 기간으로 스프린트 계획, 일일 스크럼, 스프린트 회고, 스프린트 리뷰로 구성된
        - 스프린트 계획은 제품 백로그에서 개발 항목을 선택하고 업무와 방법을 계획하는 1개월 스프린트 기준에서 최대 8시간의 미팅
        - 일일 스크럼은 3 ~ 9명의 스크럼 팀이 매일 수행하는 짧은 기립 미팅으로 진척사항과 당일 할 일을 검토하고 새로운 문제를 제기, 검토하는 회의
        - 스프린트 리뷰에서는 완료된 개발물을 검토하고 피드백 얻음
        - 스프린트 회고에서는 스프린트 작업 방식의 개선 사항을 논의
        - 스프린트 과정에서 '제품 책임자'는 제품 백로그를 작성하고 관리하며 '스크럼 마스터'는 스크럼 프로세스의 관리자
- 수주 제안서 작성 시 필요한 항목
    - WBS
        - 종속 관계를 바탕으로 프로젝트 결과물을 여러 계층으로 나눠 시각적으로 분류
    - 간트 차트
        - 프로젝트의 단계에 대한 시각적 타임라인 제공
    - 개발 방법론
- 소프트웨어 규모의 산정에서 기능 점수 방법
    - 소프트웨어가 가진 기능적 사용자 요구사항의 양을 추정
    - 개발 전이나 초기에 개발 비용을 추정할 때 기초가 됨
    - 구현 기술이나 개발 방법론과 무관하게 추정 가능
    - 기능점수 
      - 기능의 규모를 측정하기 위한 단위
      - 프로그램의 기능에 초점을 맞춘 논리적 규모 척도
      - 요구사항에 존재하는 기능의 양을 예상하여 총 규모(총 FP)를 추정할 수 있음
      - 구현 기술이나 구현 언어와 무관
      - 사무 정보 시스템의 규모 산정에 적합함
      - 보정 기능 점수(AFP)는 미보정 기능 점수(UFP)와 보정 계수(VAF)의 곱 (AFP = UFP * VAF)
    - 미보정 기능 점수(UFP)
      - 자료의 규모로부터 기능을 측정
      - 프로그램에서 표현되거나 사용된 데이터의 총량을 계량화
      - 데이터 기능(내부 논리 파일, 외부 인터페이스 파일)과 트랜잭션 기능(외부 출력, 외부 입력, 외부 조회)을 측정하고 각각의 개수에 유형의 복잡도에 따른 가중치를 곱하고 모두 합함
    - 보정 계수(VAF)
      - 먼저 기술적 복잡도를 반영하기 위해 14개의 복잡도 항목의 영향도(0~5)를 계산하고 모두 합하여 총 영향도(TDI)를 계산함
      - VAF = 0.65 + 0.01 X TDI
      - VAF = 0.65 ~ 1.35 사이의 값
    - 보정 기능 점수(AFP)
      - (AFP = UFP * VAF)
      - 프로그래밍 언어별로 기능 점수 1점을 구현하기 위해 필요한 라인수가 존재
      - 따라서 기능 점수로부터 라인수를 계산할 수 있으며 초기 단계에서 라인수 추정에 효과적인 방법
      - 프로그래머의 평균 생산성(FP/PM)이 알려져 있다면 전체 PM을 계산할 수 있음
    - 국내 기능 점수 적용 사례 
      - 'SW사업 대가 산정 가이드'에서 국내 공공부문의 SW 규모 산정 방법을 설명
      - 간이법은 기능의 유형별로 평균 복잡도를 일괄적으로 적용하는 방식
      - 기능 점수의 보정 요소로는 소프트웨어 규모, 연계복잡성, 성능 수준, 다중 사이트 운영성, 보안 수준이 있음
- CMMI(Capability Maturity Model Integration)
    - 조직의 개발 프로세스 성숙도를 평가하는 모델
    - 다양한 기업에 프로세스 개선을 위한 프레임워크를 제공
    - ISO 9001과 ISO 15504(SPICE)의 관심사를 포함한 통합 모델
- CMMI 평가 - 성숙도 수준 평가(단계적 모델)
  - 조직 전체의 프로세스 능력을 하나의 등급으로 평가
  - 1 ~ 5 사이에서 성숙도 수준을 평가
    - 수준 1(초기 상태): 소프트웨어 능력을 하나의 등급으로 평가
    - 수준 2(관리됨): 일정이나 비용 관련 기본적 관리 프로세스 위주로 관리됨
    - 수준 3(정의죔): 조직을 위한 표준 프로세스 존재, 조직의 특성에 맞게 재단될 수 있음
    - 수준 4(양적으로 관리됨): 프로젝트 활동이 정량적으로 관리되고 통제됨
    - 수준 5(최적화됨): 지속적인 개선 활동이 정착화됨 
  
- 소프트웨어의 성격별 테스트 분류
  - 블랙박스 테스트를 위한 테스트 케이스 개발방법
    - 완전 테스트는 모든 입력 조합을, 랜덤 테스트는 랜덤하게 선택된 입력을 테스트 데이터로 사용
    - 동치 분할 :입력 집합을 몇 개의 동치 클라스들로 나누어 테스트하는 것으로 요구사항에 기초하여 분할을 만든 후 각 분할에서 대표값을 선정
    - 경계값 분석 : 동치 분할 방법의 변형으로 동치 클래스를 정의한 후 경계값과 경계값 직전/직후 값을 테스트하는 것, 경계값 주변애서 오류의 가능성이 높다는 점을 가정
    - 원인-결과 그래프 : 명세서를 분석하여 원인에 해당하는 입역 조건과 그것의 출력 결과를 논리적으로 연결한 그래프를 작성하고 의사결정 태아불블로 바꾼 후 테스트 테스트 캐아스를 개발함.
  

- 소프트웨어 설계 작업의 주요 원리
    - 모듈화(문제 분할)
        - 분할과 정복의 원칙을 적용
        - 어느 수준까지 분할할지 판단 필요
        - 수평 분할 (기능들을 분리된 가지에 할당)
        - 수직 분할 (제어와 작업을 위와 아래로 분산)
    - 추상화
        - 모듈들을 추상화하여 표현
        - 추상화란 내부의 상세한 내용을 생략하고 외부 행위만을 기술하는 것. 상세 설계와 구현 작업은 추상화되어 있는 각 모듈의 명세를 구현하는 작업
        - 추상화된 시스템 모델을 통해 시스템의 분석이 가능함
        - 기능 추상화
            - 수행하는 기능으로 모듈을 명세
            - 저체를 작은 기능들로 분해
        - 데이터 추상화 
            - 데이터와 데이터 조작에 필요한 오퍼레이션을 함께 묶음
            - 객체의 상세한 구현 내용이 감춰지며 공개된 오퍼레이션만을 사용
    - 단계적 정제(하향식과 상향식 설계)
        - 하향식 설계
            - 계층 구조상에서 시스템의 주요 컴포넌트들을 찾고 그것을 낮은 수준의 컴포넌트들로 분해하는 것 
            - 메인 모듈의 설계에서 시작하여 단계적으로 구체화
        - 상향식 설계
            - 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 컴포넌트를 설계
        - 시스템 명세가 명확한 경우와 모든 것을 새로 개발하는 작업에는 하향식이 적합
        - 기존 컴포넌트들을 조합하여 시스템을 개발하는 경우에는 상향식이 적합

- 소프트웨어 비기능적 요구사항
    - 제품의 품질, 서비스나 기능상의 제약, 법률이나 표준의 준수에 관한 내용을 기술한 것
    - 사용성, 효율성, 성능, 저장소 용량, 입출력 장치의 성능, 보안, 신뢰도, 이식성 관련 요구사항 등과 프로세스 관련 요구사항 및 하드웨어 사용에 관한 것
    - 예시1 ) 사용자에게 1초 내로 피드백이 주어져야 한다.
    - 예시2 ) 인터페이스 색상이 회사의 공식 색상과 일관성이 있어야 한다.
    - 보안이 중요하다면 계층형 아키텍처를 사용하고 중요 보안 요소를 시스템의 내부 계층에 위치
    - 안정성이 요구되는 컴포넌트라면 적은 수의 서브시스템들에 두어 고립화시킴으로써 검증 비용 절감
    - 가용성이 중요하다면 주요 기능의 컴포넌트가 중복되도록 설계
- 개발 과정 중 요구사항 추출단계의 활동
    - 사용자와 인터뷰하여 시스템 사용 시나리오 작성
    - 유스케이스를 상세히 작성 후 형식화
    - JAD 회의를 통해 요구사항 명세에 관한 의견 일치 협의
    - ?
- 통합 프로세스(UP)
    - UML의 저자들이 제안한 점증적 반복적 개발 프로세스
    - 객체지향 분석과 설계를 위한 방법론으로 여러 개발 방법론의 장점을 통합한 프로세스
    - 반복적이고 점증적인 프로세스를 위한 프레임워크
    - RUP는 UP를 상세히 다듬고 HTML로 문서화한 제품
    - 생명주기
        - 도입, 정련, 구축, 전이의 4단계로 구성
        - 정련, 구축, 전이는 각각 일련의 반복으로 구성
            - 하나의 반복은 짧고 고정된 기간으로 소규모 프로젝트라 할 수 있음
            - 소구모 프로젝트의 결과물은 하나의 증분으로 실행 가능한 시스템 릴리스가 됨
            - UP가 강조하는 사항
                - 반복적 개발
                - 유스케이스 기반의 개발
                - 아키텍처를 중요시함
                - 프로젝트 초기에 중요한 위험을 다룰 것
    - UP 4단계
        - 도입(inception)
            - 1주 정도의 짧은 기간에 수행
            - 시스템의 범위를 정하며, 비즈니스 사례를 파악하고 비전을 세움
            - 주요 요구사항을 나열, 10% 정도의 유스케이스를 상세히 작성
            - 가능성 있는 해결 방안과 아키텍처를 검토하고 위험 요소를 식별
            - 일정과 비용의 개략적 추정, 실현 가능성을 조사
        - 정련(elaboration)
            - 핵심 아키텍처를 구축하고 대부분의 요구사항을 명확히 정의
            - 초가에 30%, 종료까지 80% 정도의 유스케이스를 상세히 작성
            - 높은 위험 요소를 해결하고, 일정과 자원을 상세히 추정
            - 2 ~ 6주 기간의 반복을 2 ~ 4회 수행함
            - 중요 요구사항을 설계하고 구현. 전체적으로 15% 정도를 구현
        - 구축(construction)
            - 남아 있는 부분을 설계하고 구현하여 통합함
            - 최종적으로 고객에게 인도할 준비를 함
        - 전이(transition)
            - 사용자 환경으로 시스템을 옮김
            - 반복은 사용자 피드백을 받아 보수하는 작업
- 유스케이스 다이어그램에서 표현되어야 하는 것
    - 기능적 요구사항으로서의 유스케이스
    - 시스템과 상호작용하는 액터
    - 시스템 내부와 외부를 구분하는 경계
    - 유스케이스 간 관계
    - 유스케이스 명세
- 유스케이스 간의 관계
    - include
        - 두 유스케이스에서 중복되는 기능이 있는 경우 중복된 부분을 별도의 유스케이스로 분리
        - 분리된 유스케이스로 만들면 유지보수성과 재사용성이 증가
    - extend
        - 특정 조건에서 선택적으로 사용되는 시나리오를 분리
        - 점선의 화살표를 사용하며 확장 유스케이스로부터 기본 유스케이스로 화살표가 향함
        - include 관계의 경우와 화살표 방향이 반대임
    - generalize
        - 전체적인 흐름은 동일하나 일부에서 구체적인 방법이나 내용이 틀린 경우
        - 자식 유스케이스는 부모 유스케이스에서 사용되는 흐름과 일치함
        - 예로 사용자 인증 유스케이스가 부모가 되며 아이디/암호, 지문 인식, 홍채 인식을 사용한 인증을 자식 유스케이스로 둠
- UML 스테레오 타입
    - UML 요소의 의미를 바꾸거나 명확하게 하기 위한 방법
    - <parallel>과 같이 키워트를 <>로 감싸 표현
    - 스테레오 타입 대신에 특별한 아이콘을 사용하여 표현할 때도 있음
    - ?
- 액티비티 다이어그램
    - 액티비티 
        - 액티비티는 작업의 실행을 의마하는 것으로 일련의 액션들과 이들의 제어흐름을 표현
        - 액티비티는 액션보다 상위 개념의 프로세스
        - 액티비티는 액션, 제어 노드와 객체 노드, 제어 흐름과 객체 흐름 등의 요소를 포함
        - 액션은 액티비티를 수행하기 위해 필요한 단일 작업으로 액티비티에 포함되는 하나의 단계이며 더 이상 분해되지 않는 단일 작업
        - 예를 들어 '라면 끓이기'는 액티비티이며, '물 붓기', '물 끓이기', '라면 넣기'는 액션에 해당
        - 표기법
            - 액티비티와 액션의 표기법은 동일하며 모서리가 둥근 사각형
            - 액티비티 내부에 액션들이 포함되며 액티비티의 이름은 상단에 위치
            - 액션들의 제어 흐름은 화살표로 나타냄
- 상호작용 다이어그램
	- 참여 요소와 생명선 
		- 참여 요소는 메세지를 주고받는 주체로 객체, 서브시스템, 외부 시스템, 하드웨어 등
		- 사각형으로 표시되며, 다이어그램의 상단에 적당한 간격을 두고 수평으로 배치
		- 참여 요소는 액터, 경계 객체, 제어 객체, 엔터티 객체 순으로 나타남
		- 생명선
			- 참여 요소에서 아래쪽으로 향하는 점선
			- 상호작용의 순서를 보여주기 위한 시간 축, 위에서 아래 방향으로 시간이 플러가며 길이가 시간 간격을 의미하는 것은 아님
		- 참여 요소의 이름 표기법
			- 이름[선택자] : 클래스 이름 ref 상호작용 다이어그램
				- 예시 1) :Student - Student 클래스의 익명 객체
				- 예시 2) admin:Administrator - Administrator 클래스의 admin 객체
				- 예시 3) :RegistrationSystem ref reg_detail - RegistrationSystem은 서브시스템이며 이것의 자세한 작업은 reg_detail이라는 이름의 상호작용 다이어그램에 나옴
	- 메세지
		- 메세지 또는 시그널이 전송되는 것을 이벤트 발생이라고 함
		- 메세지는 소프트웨어 설계자 관점이며 시그널은 시스템 섷계자 관점
- 시퀸스 다이어그램
	- 시퀸스 다이어그램에서 메세지의 실행 순서는 위에서 아래로 진행됨
	- 시퀸스 다이어그램과 클래스 다이어그램은 설계와 구현 사이를 연결하는 중간자 역할
- 클래스 다이어그램
    - 클래스 명세와 클래스 간의 관계를 표현
    - 시스템의 정적인 구조를 표현
    - 객체지향 프로그램을 개발할 때 많이 활용
	- 클래스는 객체에 대한 설계를 제공
	- UML에서 가장 활용도가 높은 다이어그램으로 설계 동작에 필요한 구성 요소들과 이들의 관계를 보여줌
- 상태 머신 다이어그램
	- 시스템의 단일 객체에 대한 행위를 모델링
	- 객체가 생성되어 소멸되기까지의 전 과정에서 이벤트 발생과 상태 변화를 다룸
	- 동적 행위를 모델링하나 특정 객체만을 다룸
	- 실시간 임베디드 시스템, 게임, 프로토콜 설계에 이용됨
- 배포 다이어그램
	- 소프트웨어 조각들이 실제로 어떤 하드웨어에 배치되어 실행되는지를 보여줌
	- 시스탬의 물리적 뷰에 해당
- UML 다이어그램의 요소 아이콘?